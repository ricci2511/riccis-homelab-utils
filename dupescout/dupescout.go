package dupescout

import (
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"sync"
	"syscall"

	"github.com/puzpuzpuz/xsync/v2"
)

type pair struct {
	key  string // depends on the KeyGeneratorFunc
	path string
}

// Dupescout is the main struct that holds the state of the search.
type dupescout struct {
	sem      semaphore
	wg       *sync.WaitGroup
	pairs    chan *pair
	result   chan []string
	shutdown chan os.Signal
}

func newDupeScout(workers int) *dupescout {
	return &dupescout{
		sem:      newSemaphore(workers),
		wg:       new(sync.WaitGroup),
		pairs:    make(chan *pair, 500),
		result:   make(chan []string, 1),
		shutdown: make(chan os.Signal, 1),
	}
}

// Starts the search for duplicates which can be customized by the provided Cfg struct.
//
// Will block until the search is done.
func Find(c Cfg) ([]string, error) {
	c.defaults()

	dup := newDupeScout(c.Workers)

	// Exclusive wait group for the consumer.
	// Cant reuse dup.wg since the consumer wont stop until the pairs channel is closed
	consumerWg := new(sync.WaitGroup)

	consumerWg.Add(1)
	go dup.consumePairs(consumerWg)

	dup.wg.Add(1)
	dup.gracefulShutdown()

	dup.wg.Add(1)
	err := dup.search(c.Path, &c)

	dup.wg.Wait()

	// Signal that no more pairs will be sent, triggering the consumer to process the results.
	close(dup.pairs)

	consumerWg.Wait()

	close(dup.result)

	return <-dup.result, err
}

// Consumes pairs received from the pairs channel and processes
// them into the result channel once no more pairs are sent.
func (dup *dupescout) consumePairs(consumerWg *sync.WaitGroup) {
	defer dup.sem.release()
	defer consumerWg.Done()

	dup.sem.acquire()

	m := xsync.NewMapOf[[]string]()

	for p := range dup.pairs {
		paths, ok := m.Load(p.key)
		if ok {
			m.Store(p.key, append(paths, p.path))
		} else {
			m.Store(p.key, []string{p.path})
		}
	}

	dup.result <- processResults(m)
}

// Produces a pair with the key which is generated by the KeyGeneratorFunc and the path
// which is then sent to the pairs channel.
func (dup *dupescout) producePair(path string, keyGen KeyGeneratorFunc) {
	defer dup.workerDone()
	dup.sem.acquire()

	// Stop pair production if a shutdown signal has been received.
	if dup.shuttingDown() {
		return
	}

	key, err := keyGen(path)
	if err != nil {
		log.Println(err)
	}

	if key == "" {
		return
	}

	dup.pairs <- &pair{key, path}
}

// Recursively searches the provided directory for files and subdirectories.
func (dup *dupescout) search(dir string, c *Cfg) error {
	defer dup.workerDone()
	dup.sem.acquire()

	// Stop searching if a shutdown signal has been received.
	if dup.shuttingDown() {
		return nil
	}

	return filepath.WalkDir(dir, func(path string, de os.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if !c.HiddenInclude && strings.HasPrefix(de.Name(), ".") {
			if de.IsDir() {
				return filepath.SkipDir
			}

			return nil
		}

		if de.IsDir() && path != dir {
			if c.skipDir(path) {
				return filepath.SkipDir
			}

			dup.wg.Add(1)
			go dup.search(path, c)
			return filepath.SkipDir
		}

		if de.Type().IsRegular() {
			fi, err := de.Info()
			if err != nil || fi.Size() == 0 {
				return nil
			}

			if !c.satisfiesExtFilter(path) {
				return nil
			}

			dup.wg.Add(1)
			go dup.producePair(path, c.KeyGenerator)
		}

		return nil
	})
}

// Processes a map of keys to paths and returns a slice of paths that are duplicates.
func processResults(m *xsync.MapOf[string, []string]) []string {
	res := []string{}

	m.Range(func(key string, paths []string) bool {
		if len(paths) > 1 {
			res = append(res, paths...)
		}

		return true
	})

	return res
}

// Sets up a signal handler worker for graceful shutdown.
func (dup *dupescout) gracefulShutdown() {
	defer dup.workerDone()
	dup.sem.acquire()

	signal.Notify(dup.shutdown, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		<-dup.shutdown
		log.Println("\nReceived signal, shutting down after current workers are done...")
		close(dup.shutdown)
	}()
}

// Helper to check if a shutdown signal has been received.
func (dup *dupescout) shuttingDown() bool {
	select {
	case <-dup.shutdown:
		return true
	default:
		return false
	}
}

// Helper to signal that a worker is done.
func (dup *dupescout) workerDone() {
	dup.wg.Done()
	dup.sem.release()
}
