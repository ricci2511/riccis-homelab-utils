package dupescout

import (
	"context"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"

	"golang.org/x/sync/semaphore"
)

type pair struct {
	key  string // depends on the KeyGeneratorFuncÂ§
	path string
}

// Map of keys to paths.
type results map[string][]string

type Dupes []string

// Starts the search for duplicates which can be customized by the provided Cfg struct.
func Start(c Cfg) Dupes {
	c.defaults()

	workers := runtime.GOMAXPROCS(0) * 2
	sem := semaphore.NewWeighted(int64(workers))
	pairs := make(chan pair)
	result := make(chan results)
	wg := new(sync.WaitGroup)

	go consumePairs(pairs, result)

	wg.Add(1)

	err := search(c.Path, pairs, sem, wg, &c)
	if err != nil {
		log.Println(err)
	}

	wg.Wait()

	close(pairs)

	return processDupes(result)
}

// Consumes pairs received from the pairs channel and adds them to the results map.
func consumePairs(pairs <-chan pair, result chan<- results) {
	m := make(results)
	mu := new(sync.RWMutex)

	for p := range pairs {
		mu.Lock()
		m[p.key] = append(m[p.key], p.path)
		mu.Unlock()
	}

	result <- m
}

// Produces a pair with the key which is generated by the KeyGeneratorFunc and the path
// which is then sent to the pairs channel.
func producePair(path string, pairs chan<- pair, sem *semaphore.Weighted, wg *sync.WaitGroup, c *Cfg) {
	defer wg.Done()
	defer sem.Release(1)

	if err := sem.Acquire(context.Background(), 1); err != nil {
		log.Printf("Failed to acquire semaphore: %v", err)
		return
	}

	key, err := c.KeyGenerator(path)
	if err != nil {
		log.Println(err)
	}

	if key == "" {
		return
	}

	pairs <- pair{key, path}
}

// Recursively searches the provided directory for files and subdirectories.
func search(dir string, pairs chan<- pair, sem *semaphore.Weighted, wg *sync.WaitGroup, c *Cfg) error {
	defer wg.Done()
	defer sem.Release(1)

	if err := sem.Acquire(context.Background(), 1); err != nil {
		return err
	}

	return filepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if c.IgnoreHidden && strings.HasPrefix(fi.Name(), ".") {
			if fi.Mode().IsDir() {
				return filepath.SkipDir
			}

			return nil
		}

		if fi.Mode().IsDir() && path != dir {
			wg.Add(1)
			go search(path, pairs, sem, wg, c)
			return filepath.SkipDir
		}

		if fi.Mode().IsRegular() && fi.Size() > 0 {
			// If an extension filter is set, skip files that don't match.
			if !c.satisfiesExtFilter(path) {
				return nil
			}

			wg.Add(1)
			go producePair(path, pairs, sem, wg, c)
		}

		return nil
	})
}

// Processes the results map and returns a slice of paths that have duplicates.
func processDupes(result <-chan results) Dupes {
	dupes := Dupes{}

	for _, paths := range <-result {
		if len(paths) > 1 {
			dupes = append(dupes, paths...)
		}
	}

	return dupes
}
