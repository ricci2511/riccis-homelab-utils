package dupescout

import (
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
)

type pair struct {
	key  string // depends on the KeyGeneratorFuncÂ§
	path string
}

// Map of keys to paths.
type results map[string][]string

// Dupescout is the main struct that holds the state of the search.
type dupescout struct {
	sem    chan bool
	wg     *sync.WaitGroup
	pairs  chan pair
	result chan results
}

// Starts the search for duplicates which can be customized by the provided Cfg struct.
func Start(c Cfg) []string {
	c.defaults()

	workers := runtime.GOMAXPROCS(0) * 2
	sem := make(chan bool, workers)
	wg := new(sync.WaitGroup)
	pairs := make(chan pair)
	result := make(chan results)

	dup := &dupescout{sem, wg, pairs, result}

	go dup.consumePairs()

	wg.Add(1)

	err := dup.search(c.Path, &c)
	if err != nil {
		log.Println(err)
	}

	wg.Wait()

	close(pairs)

	return processDupes(result)
}

// Consumes pairs received from the pairs channel and adds them to the results map.
func (dup *dupescout) consumePairs() {
	m := make(results)
	mu := new(sync.RWMutex)

	for p := range dup.pairs {
		mu.Lock()
		m[p.key] = append(m[p.key], p.path)
		mu.Unlock()
	}

	dup.result <- m
}

// Produces a pair with the key which is generated by the KeyGeneratorFunc and the path
// which is then sent to the pairs channel.
func (dup *dupescout) producePair(path string, keyGen keyGeneratorFunc) {
	defer dup.workerDone()
	dup.sem <- true

	key, err := keyGen(path)
	if err != nil {
		log.Println(err)
	}

	if key == "" {
		return
	}

	dup.pairs <- pair{key, path}
}

// Recursively searches the provided directory for files and subdirectories.
func (dup *dupescout) search(dir string, c *Cfg) error {
	defer dup.workerDone()
	dup.sem <- true

	return filepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if c.IgnoreHidden && strings.HasPrefix(fi.Name(), ".") {
			if fi.Mode().IsDir() {
				return filepath.SkipDir
			}

			return nil
		}

		if fi.Mode().IsDir() && path != dir {
			dup.wg.Add(1)
			go dup.search(path, c)
			return filepath.SkipDir
		}

		if fi.Mode().IsRegular() && fi.Size() > 0 {
			// If an extension filter is set, skip files that don't match.
			if !c.satisfiesExtFilter(path) {
				return nil
			}

			dup.wg.Add(1)
			go dup.producePair(path, c.KeyGenerator)
		}

		return nil
	})
}

// Processes the results map and returns a slice of paths that have duplicates.
func processDupes(result <-chan results) []string {
	dupes := []string{}

	for _, paths := range <-result {
		if len(paths) > 1 {
			dupes = append(dupes, paths...)
		}
	}

	return dupes
}

// Helper function to signal that a worker is done.
func (dup *dupescout) workerDone() {
	dup.wg.Done()
	func() { <-dup.sem }()
}
